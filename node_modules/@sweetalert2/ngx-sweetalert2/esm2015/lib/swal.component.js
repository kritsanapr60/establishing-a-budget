import { __awaiter } from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`
 *     and `didDestroy`.
 *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,
 *     there can't be multiple listeners on them, and we need the values they can/must return.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './sweetalert2-loader.service';
export class SwalComponent {
    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
         */
        this.willOpen = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
         */
        this.didOpen = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is
         * repainted on the screen).
         * Typically, this will happen after `Swal.fire()` or `Swal.update()`.
         * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over
         * {@link willOpen}.
         */
        this.didRender = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup
         * being fired).
         */
        this.willClose = new EventEmitter();
        /**
         * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to
         * another popup being fired).
         */
        this.didClose = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another
         * popup.
         * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer
         * {@link didDestroy} over {@link didClose}.
         */
        this.didDestroy = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * The event value ($event) can be either:
         *  - by default, just `true`,
         *  - when using {@link input}, the input value,
         *  - when using {@link preConfirm}, the return value of this function.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Deny".
         * This event bears no value.
         * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and
         * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.
         *
         * Example:
         *     <swal (deny)="handleDeny()"></swal>
         *
         *     public handleDeny(): void {
         *     }
         */
        this.deny = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when
         * the modal was programmatically closed (through {@link close} for example).
         *
         * Example:
         *     <swal (dismiss)="handleDismiss($event)"></swal>
         *
         *     public handleDismiss(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.dismiss = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from @Inputs, so we can know precisely
         * what options we have to send to {@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the @Inputs for practical/philosophical reasons ;
     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
     */
    set swalOptions(options) {
        //=> Update properties
        Object.assign(this, options);
        //=> Mark changed properties as touched
        const touchedKeys = Object.keys(options);
        touchedKeys.forEach(this.markTouched);
    }
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     */
    get swalOptions() {
        //=> We will compute the options object based on the option keys that are known to have changed.
        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
        //   avoiding side effects.
        return [...this.touchedProps].reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: this[key] })), {});
    }
    set swalVisible(visible) {
        visible ? this.fire() : this.close();
    }
    get swalVisible() {
        return this.isCurrentlyShown;
    }
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    ngOnInit() {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    }
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    ngAfterViewInit() {
        const fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    }
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    ngOnChanges(changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((key) => !key.startsWith('swal'))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    }
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    ngOnDestroy() {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        const dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.close();
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (dismiss)="myHandler($event)" can be used in templates.
     */
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            const swal = yield this.sweetAlert2Loader.swal;
            const userOptions = this.swalOptions;
            //=> Build the SweetAlert2 options
            const options = Object.assign(Object.assign({}, userOptions), { 
                //=> Handle modal lifecycle events
                willOpen: composeHook(userOptions.willOpen, (modalElement) => {
                    this.willOpen.emit({ modalElement });
                }), didOpen: composeHook(userOptions.didOpen, (modalElement) => {
                    this.isCurrentlyShown = true;
                    this.didOpen.emit({ modalElement });
                }), didRender: composeHook(userOptions.didRender, (modalElement) => {
                    this.didRender.emit({ modalElement });
                }), willClose: composeHook(userOptions.willClose, (modalElement) => {
                    this.isCurrentlyShown = false;
                    this.willClose.emit({ modalElement });
                }), didClose: composeHook(userOptions.didClose, () => {
                    this.didClose.emit();
                }), didDestroy: composeHook(userOptions.didDestroy, () => {
                    this.didDestroy.emit();
                }) });
            //=> Show the Swal! And wait for confirmation or dimissal.
            const result = yield swal.fire(options);
            //=> Emit on (confirm), (deny) or (dismiss)
            switch (true) {
                case result.isConfirmed:
                    this.confirm.emit(result.value);
                    break;
                case result.isDenied:
                    this.deny.emit();
                    break;
                case result.isDismissed:
                    this.dismiss.emit(result.dismiss);
                    break;
            }
            return result;
            function composeHook(userHook, libHook) {
                return (...args) => (libHook(...args), userHook === null || userHook === void 0 ? void 0 : userHook(...args));
            }
        });
    }
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).
     *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.
     *               {@see Swal.close}.
     */
    close(result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            swal.close(result);
        });
    }
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    update(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options) {
                this.swalOptions = options;
            }
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            const allOptions = this.swalOptions;
            const updatableOptions = Object.keys(allOptions)
                .filter(swal.isUpdatableParameter)
                .reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: allOptions[key] })), {});
            swal.update(updatableOptions);
        });
    }
}
SwalComponent.ɵfac = function SwalComponent_Factory(t) { return new (t || SwalComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.SweetAlert2LoaderService), ɵngcc0.ɵɵdirectiveInject(fireOnInitToken), ɵngcc0.ɵɵdirectiveInject(dismissOnDestroyToken)); };
SwalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SwalComponent, selectors: [["swal"]], inputs: { swalOptions: "swalOptions", swalVisible: "swalVisible", title: "title", titleText: "titleText", text: "text", html: "html", footer: "footer", icon: "icon", iconColor: "iconColor", iconHtml: "iconHtml", backdrop: "backdrop", toast: "toast", target: "target", input: "input", width: "width", padding: "padding", background: "background", position: "position", grow: "grow", showClass: "showClass", hideClass: "hideClass", customClass: "customClass", timer: "timer", timerProgressBar: "timerProgressBar", animation: "animation", heightAuto: "heightAuto", allowOutsideClick: "allowOutsideClick", allowEscapeKey: "allowEscapeKey", allowEnterKey: "allowEnterKey", stopKeydownPropagation: "stopKeydownPropagation", keydownListenerCapture: "keydownListenerCapture", showConfirmButton: "showConfirmButton", showDenyButton: "showDenyButton", showCancelButton: "showCancelButton", confirmButtonText: "confirmButtonText", denyButtonText: "denyButtonText", cancelButtonText: "cancelButtonText", confirmButtonColor: "confirmButtonColor", denyButtonColor: "denyButtonColor", cancelButtonColor: "cancelButtonColor", confirmButtonAriaLabel: "confirmButtonAriaLabel", denyButtonAriaLabel: "denyButtonAriaLabel", cancelButtonAriaLabel: "cancelButtonAriaLabel", buttonsStyling: "buttonsStyling", reverseButtons: "reverseButtons", focusConfirm: "focusConfirm", focusDeny: "focusDeny", focusCancel: "focusCancel", showCloseButton: "showCloseButton", closeButtonHtml: "closeButtonHtml", closeButtonAriaLabel: "closeButtonAriaLabel", loaderHtml: "loaderHtml", showLoaderOnConfirm: "showLoaderOnConfirm", preConfirm: "preConfirm", preDeny: "preDeny", imageUrl: "imageUrl", imageWidth: "imageWidth", imageHeight: "imageHeight", imageAlt: "imageAlt", inputLabel: "inputLabel", inputPlaceholder: "inputPlaceholder", inputValue: "inputValue", inputOptions: "inputOptions", inputAutoTrim: "inputAutoTrim", inputAttributes: "inputAttributes", inputValidator: "inputValidator", returnInputValueOnDeny: "returnInputValueOnDeny", validationMessage: "validationMessage", progressSteps: "progressSteps", currentProgressStep: "currentProgressStep", progressStepsDistance: "progressStepsDistance", scrollbarPadding: "scrollbarPadding", swalFireOnInit: "swalFireOnInit", swalDismissOnDestroy: "swalDismissOnDestroy" }, outputs: { willOpen: "willOpen", didOpen: "didOpen", didRender: "didRender", willClose: "willClose", didClose: "didClose", didDestroy: "didDestroy", confirm: "confirm", deny: "deny", dismiss: "dismiss" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function SwalComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SwalComponent.ctorParameters = () => [
    { type: SweetAlert2LoaderService },
    { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
];
SwalComponent.propDecorators = {
    title: [{ type: Input }],
    titleText: [{ type: Input }],
    text: [{ type: Input }],
    html: [{ type: Input }],
    footer: [{ type: Input }],
    icon: [{ type: Input }],
    iconColor: [{ type: Input }],
    iconHtml: [{ type: Input }],
    backdrop: [{ type: Input }],
    toast: [{ type: Input }],
    target: [{ type: Input }],
    input: [{ type: Input }],
    width: [{ type: Input }],
    padding: [{ type: Input }],
    background: [{ type: Input }],
    position: [{ type: Input }],
    grow: [{ type: Input }],
    showClass: [{ type: Input }],
    hideClass: [{ type: Input }],
    customClass: [{ type: Input }],
    timer: [{ type: Input }],
    timerProgressBar: [{ type: Input }],
    animation: [{ type: Input }],
    heightAuto: [{ type: Input }],
    allowOutsideClick: [{ type: Input }],
    allowEscapeKey: [{ type: Input }],
    allowEnterKey: [{ type: Input }],
    stopKeydownPropagation: [{ type: Input }],
    keydownListenerCapture: [{ type: Input }],
    showConfirmButton: [{ type: Input }],
    showDenyButton: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    confirmButtonText: [{ type: Input }],
    denyButtonText: [{ type: Input }],
    cancelButtonText: [{ type: Input }],
    confirmButtonColor: [{ type: Input }],
    denyButtonColor: [{ type: Input }],
    cancelButtonColor: [{ type: Input }],
    confirmButtonAriaLabel: [{ type: Input }],
    denyButtonAriaLabel: [{ type: Input }],
    cancelButtonAriaLabel: [{ type: Input }],
    buttonsStyling: [{ type: Input }],
    reverseButtons: [{ type: Input }],
    focusConfirm: [{ type: Input }],
    focusDeny: [{ type: Input }],
    focusCancel: [{ type: Input }],
    showCloseButton: [{ type: Input }],
    closeButtonHtml: [{ type: Input }],
    closeButtonAriaLabel: [{ type: Input }],
    loaderHtml: [{ type: Input }],
    showLoaderOnConfirm: [{ type: Input }],
    preConfirm: [{ type: Input }],
    preDeny: [{ type: Input }],
    imageUrl: [{ type: Input }],
    imageWidth: [{ type: Input }],
    imageHeight: [{ type: Input }],
    imageAlt: [{ type: Input }],
    inputLabel: [{ type: Input }],
    inputPlaceholder: [{ type: Input }],
    inputValue: [{ type: Input }],
    inputOptions: [{ type: Input }],
    inputAutoTrim: [{ type: Input }],
    inputAttributes: [{ type: Input }],
    inputValidator: [{ type: Input }],
    returnInputValueOnDeny: [{ type: Input }],
    validationMessage: [{ type: Input }],
    progressSteps: [{ type: Input }],
    currentProgressStep: [{ type: Input }],
    progressStepsDistance: [{ type: Input }],
    scrollbarPadding: [{ type: Input }],
    swalOptions: [{ type: Input }],
    swalFireOnInit: [{ type: Input }],
    swalDismissOnDestroy: [{ type: Input }],
    swalVisible: [{ type: Input }],
    willOpen: [{ type: Output }],
    didOpen: [{ type: Output }],
    didRender: [{ type: Output }],
    willClose: [{ type: Output }],
    didClose: [{ type: Output }],
    didDestroy: [{ type: Output }],
    confirm: [{ type: Output }],
    deny: [{ type: Output }],
    dismiss: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwalComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'swal',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc1.SweetAlert2LoaderService }, { type: Boolean, decorators: [{
                type: Inject,
                args: [fireOnInitToken]
            }] }, { type: Boolean, decorators: [{
                type: Inject,
                args: [dismissOnDestroyToken]
            }] }]; }, { willOpen: [{
            type: Output
        }], didOpen: [{
            type: Output
        }], didRender: [{
            type: Output
        }], willClose: [{
            type: Output
        }], didClose: [{
            type: Output
        }], didDestroy: [{
            type: Output
        }], confirm: [{
            type: Output
        }], deny: [{
            type: Output
        }], dismiss: [{
            type: Output
        }], swalOptions: [{
            type: Input
        }], swalVisible: [{
            type: Input
        }], title: [{
            type: Input
        }], titleText: [{
            type: Input
        }], text: [{
            type: Input
        }], html: [{
            type: Input
        }], footer: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconColor: [{
            type: Input
        }], iconHtml: [{
            type: Input
        }], backdrop: [{
            type: Input
        }], toast: [{
            type: Input
        }], target: [{
            type: Input
        }], input: [{
            type: Input
        }], width: [{
            type: Input
        }], padding: [{
            type: Input
        }], background: [{
            type: Input
        }], position: [{
            type: Input
        }], grow: [{
            type: Input
        }], showClass: [{
            type: Input
        }], hideClass: [{
            type: Input
        }], customClass: [{
            type: Input
        }], timer: [{
            type: Input
        }], timerProgressBar: [{
            type: Input
        }], animation: [{
            type: Input
        }], heightAuto: [{
            type: Input
        }], allowOutsideClick: [{
            type: Input
        }], allowEscapeKey: [{
            type: Input
        }], allowEnterKey: [{
            type: Input
        }], stopKeydownPropagation: [{
            type: Input
        }], keydownListenerCapture: [{
            type: Input
        }], showConfirmButton: [{
            type: Input
        }], showDenyButton: [{
            type: Input
        }], showCancelButton: [{
            type: Input
        }], confirmButtonText: [{
            type: Input
        }], denyButtonText: [{
            type: Input
        }], cancelButtonText: [{
            type: Input
        }], confirmButtonColor: [{
            type: Input
        }], denyButtonColor: [{
            type: Input
        }], cancelButtonColor: [{
            type: Input
        }], confirmButtonAriaLabel: [{
            type: Input
        }], denyButtonAriaLabel: [{
            type: Input
        }], cancelButtonAriaLabel: [{
            type: Input
        }], buttonsStyling: [{
            type: Input
        }], reverseButtons: [{
            type: Input
        }], focusConfirm: [{
            type: Input
        }], focusDeny: [{
            type: Input
        }], focusCancel: [{
            type: Input
        }], showCloseButton: [{
            type: Input
        }], closeButtonHtml: [{
            type: Input
        }], closeButtonAriaLabel: [{
            type: Input
        }], loaderHtml: [{
            type: Input
        }], showLoaderOnConfirm: [{
            type: Input
        }], preConfirm: [{
            type: Input
        }], preDeny: [{
            type: Input
        }], imageUrl: [{
            type: Input
        }], imageWidth: [{
            type: Input
        }], imageHeight: [{
            type: Input
        }], imageAlt: [{
            type: Input
        }], inputLabel: [{
            type: Input
        }], inputPlaceholder: [{
            type: Input
        }], inputValue: [{
            type: Input
        }], inputOptions: [{
            type: Input
        }], inputAutoTrim: [{
            type: Input
        }], inputAttributes: [{
            type: Input
        }], inputValidator: [{
            type: Input
        }], returnInputValueOnDeny: [{
            type: Input
        }], validationMessage: [{
            type: Input
        }], progressSteps: [{
            type: Input
        }], currentProgressStep: [{
            type: Input
        }], progressStepsDistance: [{
            type: Input
        }], scrollbarPadding: [{
            type: Input
        }], swalFireOnInit: [{
            type: Input
        }], swalDismissOnDestroy: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Byb2plY3RzL25neC1zd2VldGFsZXJ0Mi9zcmMvbGliL3N3YWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ1ksdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM5RSxNQUFNLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQU9ILE1BQU0sT0FBTyxhQUFhO0FBQUcsSUFvUHpCLFlBQ3FCLGlCQUEyQyxFQUNsQixxQkFBOEIsRUFDeEIsMkJBQW9DO0FBQzVGLFFBSHlCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMEI7QUFBQyxRQUNuQiwwQkFBcUIsR0FBckIscUJBQXFCLENBQVM7QUFBQyxRQUN6QixnQ0FBMkIsR0FBM0IsMkJBQTJCLENBQVM7QUFBQyxRQWpIekY7QUFDSjtBQUNJLFdBQUc7QUFDUCxRQUNvQixhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQXdCLENBQUM7QUFDeEUsUUFDSTtBQUNKO0FBQ0ksV0FBRztBQUNQLFFBQ29CLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBdUIsQ0FBQztBQUN0RSxRQUNJO0FBQ0o7QUFDSTtBQUNJO0FBQ0k7QUFDSTtBQUVKLFdBREw7QUFDUCxRQUNvQixjQUFTLEdBQUcsSUFBSSxZQUFZLEVBQXlCLENBQUM7QUFDMUUsUUFDSTtBQUNKO0FBQ0k7QUFFSixXQURPO0FBQ1AsUUFDb0IsY0FBUyxHQUFHLElBQUks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b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LFxuICAgIE91dHB1dCwgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBTd2FsLCB7IFN3ZWV0QWxlcnRPcHRpb25zLCBTd2VldEFsZXJ0UmVzdWx0LCBTd2VldEFsZXJ0VXBkYXRhYmxlUGFyYW1ldGVycyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IGRpc21pc3NPbkRlc3Ryb3lUb2tlbiwgZmlyZU9uSW5pdFRva2VuIH0gZnJvbSAnLi9kaSc7XG5pbXBvcnQgKiBhcyBldmVudHMgZnJvbSAnLi9zd2FsLWV2ZW50cyc7XG5pbXBvcnQgeyBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UgfSBmcm9tICcuL3N3ZWV0YWxlcnQyLWxvYWRlci5zZXJ2aWNlJztcblxuLyoqXG4gKiA8c3dhbD4gY29tcG9uZW50LiBTZWUgdGhlIFJFQURNRS5tZCBmb3IgdXNhZ2UuXG4gKlxuICogSXQgY29udGFpbnMgYSBidW5jaCBvZiBASW5wdXRzIHRoYXQgaGF2ZSBhIHBlcmZlY3QgMToxIG1hcHBpbmcgd2l0aCBTd2VldEFsZXJ0MiBvcHRpb25zLlxuICogVGhlaXIgdHlwZXMgYXJlIGRpcmVjdGx5IGNvbWluZyBmcm9tIFN3ZWV0QWxlcnQyIHR5cGVzIGRlZmludGl0aW9ucywgbWVhbmluZyB0aGF0IG5neC1zd2VldGFsZXJ0MiBpcyB0aWdodGx5IGNvdXBsZWRcbiAqIHRvIFN3ZWV0QWxlcnQyLCBidXQgYWxzbyBpcyB0eXBlLXNhZmUgZXZlbiBpZiBib3RoIGxpYnJhcmllcyBkbyBub3QgZXZvbHZlIGluIHN5bmMuXG4gKlxuICogKD8pIElmIHlvdSB3YW50IHRvIHVzZSBhbiBvYmplY3QgdGhhdCBkZWNsYXJlcyB0aGUgU3dlZXRBbGVydDIgb3B0aW9ucyBhbGwgYXQgb25jZSByYXRoZXIgdGhhbiBtYW55IEBJbnB1dHMsXG4gKiAgICAgdGFrZSBhIGxvb2sgYXQgW3N3YWxPcHRpb25zXSwgdGhhdCBsZXRzIHlvdSBwYXNzIGEgZnVsbCB7QGxpbmsgU3dlZXRBbGVydE9wdGlvbnN9IG9iamVjdC5cbiAqXG4gKiAoPykgSWYgeW91IGFyZSByZWFkaW5nIHRoZSBUeXBlU2NyaXB0IHNvdXJjZSBvZiB0aGlzIGNvbXBvbmVudCwgeW91IG1heSB0aGluayB0aGF0IGl0J3MgYSBsb3Qgb2YgY29kZS5cbiAqICAgICBCZSBzdXJlIHRoYXQgYSBsb3Qgb2YgdGhpcyBjb2RlIGlzIHR5cGVzIGFuZCBBbmd1bGFyIGJvaWxlcnBsYXRlLiBDb21waWxlZCBhbmQgbWluaWZpZWQgY29kZSBpcyBtdWNoIHNtYWxsZXIuXG4gKiAgICAgSWYgeW91IGFyZSByZWFsbHkgY29uY2VybmVkIGFib3V0IHBlcmZvcm1hbmNlIGFuZC9vciBkb24ndCBjYXJlIGFib3V0IHRoZSBBUEkgYW5kIGl0cyBjb252ZW5pZW50IGludGVncmF0aW9uXG4gKiAgICAgd2l0aCBBbmd1bGFyIChub3RhYmx5IGNoYW5nZSBkZXRlY3Rpb24gYW5kIHRyYW5zY2x1c2lvbiksIHlvdSBtYXkgdG90YWxseSB1c2UgU3dlZXRBbGVydDIgbmF0aXZlbHkgYXMgd2VsbCA7KVxuICpcbiAqIC8hXFwgU29tZSBTd2VldEFsZXJ0IG9wdGlvbnMgYXJlbid0IEBJbnB1dHMgYnV0IEBPdXRwdXRzOiBgd2lsbE9wZW5gLCBgZGlkT3BlbmAsIGBkaWRSZW5kZXJgLCBgd2lsbENsb3NlYCwgYGRpZENsb3NlYFxuICogICAgIGFuZCBgZGlkRGVzdHJveWAuXG4gKiAgICAgSG93ZXZlciwgYHByZUNvbmZpcm1gLCBgcHJlRGVueWAgYW5kIGBpbnB1dFZhbGlkYXRvcmAgYXJlIHN0aWxsIEBJbnB1dHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgZXZlbnQgaGFuZGxlcnMsXG4gKiAgICAgdGhlcmUgY2FuJ3QgYmUgbXVsdGlwbGUgbGlzdGVuZXJzIG9uIHRoZW0sIGFuZCB3ZSBuZWVkIHRoZSB2YWx1ZXMgdGhleSBjYW4vbXVzdCByZXR1cm4uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ3N3YWwnLFxuICAgIHRlbXBsYXRlOiAnJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTd2FsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgQElucHV0KCkgcHVibGljIHRpdGxlOiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGVUZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGVUZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIHRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0ZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydodG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvb3RlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2Zvb3RlciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uOiBTd2VldEFsZXJ0T3B0aW9uc1snaWNvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydpY29uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaWNvbkh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydpY29uSHRtbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBiYWNrZHJvcDogU3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tkcm9wJ107XG4gICAgQElucHV0KCkgcHVibGljIHRvYXN0OiBTd2VldEFsZXJ0T3B0aW9uc1sndG9hc3QnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGFyZ2V0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGFyZ2V0J107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgd2lkdGg6IFN3ZWV0QWxlcnRPcHRpb25zWyd3aWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwYWRkaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1sncGFkZGluZyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBiYWNrZ3JvdW5kOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2dyb3VuZCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwb3NpdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Bvc2l0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGdyb3c6IFN3ZWV0QWxlcnRPcHRpb25zWydncm93J107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBoaWRlQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydoaWRlQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY3VzdG9tQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXN0b21DbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aW1lcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyJ107XG4gICAgQElucHV0KCkgcHVibGljIHRpbWVyUHJvZ3Jlc3NCYXI6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aW1lclByb2dyZXNzQmFyJ107XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBzaG93Q2xhc3MgYW5kIGhpZGVDbGFzcyBpbnN0ZWFkICovXG4gICAgQElucHV0KCkgcHVibGljIGFuaW1hdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ2FuaW1hdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBoZWlnaHRBdXRvOiBTd2VldEFsZXJ0T3B0aW9uc1snaGVpZ2h0QXV0byddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd091dHNpZGVDbGljazogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93T3V0c2lkZUNsaWNrJ107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RXNjYXBlS2V5OiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dFc2NhcGVLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dFbnRlcktleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RW50ZXJLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc3RvcEtleWRvd25Qcm9wYWdhdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3N0b3BLZXlkb3duUHJvcGFnYXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMga2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTogU3dlZXRBbGVydE9wdGlvbnNbJ2tleWRvd25MaXN0ZW5lckNhcHR1cmUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NvbmZpcm1CdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q29uZmlybUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93RGVueUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dEZW55QnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDYW5jZWxCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2FuY2VsQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvblRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZGVueUJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydkZW55QnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZGVueUJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snZGVueUJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZGVueUJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2RlbnlCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGJ1dHRvbnNTdHlsaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1snYnV0dG9uc1N0eWxpbmcnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcmV2ZXJzZUJ1dHRvbnM6IFN3ZWV0QWxlcnRPcHRpb25zWydyZXZlcnNlQnV0dG9ucyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0NvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0NvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNEZW55OiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNEZW55J107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ2FuY2VsOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDYW5jZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0Nsb3NlQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0Nsb3NlQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGNsb3NlQnV0dG9uSHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2Nsb3NlQnV0dG9uSHRtbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjbG9zZUJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2Nsb3NlQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGxvYWRlckh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydsb2FkZXJIdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dMb2FkZXJPbkNvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93TG9hZGVyT25Db25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIHByZUNvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydwcmVDb25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIHByZURlbnk6IFN3ZWV0QWxlcnRPcHRpb25zWydwcmVEZW55J107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlVXJsOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VVcmwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VXaWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlV2lkdGgnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VIZWlnaHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUhlaWdodCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUFsdDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlQWx0J107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0TGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dExhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0UGxhY2Vob2xkZXI6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFBsYWNlaG9sZGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0VmFsdWU6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbHVlJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0T3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0T3B0aW9ucyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dEF1dG9UcmltOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdXRvVHJpbSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dEF0dHJpYnV0ZXM6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF0dHJpYnV0ZXMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWxpZGF0b3I6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbGlkYXRvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyByZXR1cm5JbnB1dFZhbHVlT25EZW55OiBTd2VldEFsZXJ0T3B0aW9uc1sncmV0dXJuSW5wdXRWYWx1ZU9uRGVueSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB2YWxpZGF0aW9uTWVzc2FnZTogU3dlZXRBbGVydE9wdGlvbnNbJ3ZhbGlkYXRpb25NZXNzYWdlJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHM6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzJ107XG4gICAgQElucHV0KCkgcHVibGljIGN1cnJlbnRQcm9ncmVzc1N0ZXA6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXJyZW50UHJvZ3Jlc3NTdGVwJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHNEaXN0YW5jZTogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHNEaXN0YW5jZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzY3JvbGxiYXJQYWRkaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1snc2Nyb2xsYmFyUGFkZGluZyddO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IG9mIFN3ZWV0QWxlcnQyIG5hdGl2ZSBvcHRpb25zLCB1c2VmdWwgaWY6XG4gICAgICogIC0geW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZSBASW5wdXRzIGZvciBwcmFjdGljYWwvcGhpbG9zb3BoaWNhbCByZWFzb25zIDtcbiAgICAgKiAgLSB0aGVyZSBhcmUgbWlzc2luZyBASW5wdXRzIGJlY2F1c2Ugbmd4LXN3ZWV0YWxlcnQyIGlzbid0IHVwLXRvLWRhdGUgd2l0aCBTd2VldEFsZXJ0MidzIGxhdGVzdCBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogLyFcXCBQbGVhc2Ugbm90ZSB0aGF0IHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkb2VzIE5PVCBlcmFzZSB3aGF0IGhhcyBiZWVuIHNldCBiZWZvcmUgdW5sZXNzIHlvdSBzcGVjaWZ5IHRoZVxuICAgICAqICAgICBwcmV2aW91cyBwcm9wZXJ0aWVzIHlvdSB3YW50IHRvIGVyYXNlIGFnYWluLlxuICAgICAqICAgICBJZS4gc2V0dGluZyB7IHRpdGxlOiAnVGl0bGUnIH0gYW5kIHRoZW4geyB0ZXh0OiAnVGV4dCcgfSB3aWxsIGdpdmUgeyB0aXRsZTogJ1RpdGxlJywgdGV4dDogJ1RleHQnIH0uXG4gICAgICpcbiAgICAgKiAvIVxcIEJlIGF3YXJlIHRoYXQgdGhlIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCB3aWxsIG92ZXJyaWRlIHRoZSBASW5wdXRzIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHN3YWxPcHRpb25zKG9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zKSB7XG4gICAgICAgIC8vPT4gVXBkYXRlIHByb3BlcnRpZXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAvLz0+IE1hcmsgY2hhbmdlZCBwcm9wZXJ0aWVzIGFzIHRvdWNoZWRcbiAgICAgICAgY29uc3QgdG91Y2hlZEtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKSBhcyBBcnJheTxrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucz47XG4gICAgICAgIHRvdWNoZWRLZXlzLmZvckVhY2godGhpcy5tYXJrVG91Y2hlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG9wdGlvbnMgb2JqZWN0IHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIFN3ZWV0QWxlcnQyLlxuICAgICAqIE9ubHkgdGhlIHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gc2V0IGF0IGxlYXN0IG9uY2Ugb24gdGhpcyBjb21wb25lbnQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBNb3N0bHkgZm9yIGludGVybmFsIHVzYWdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3dhbE9wdGlvbnMoKTogU3dlZXRBbGVydE9wdGlvbnMge1xuICAgICAgICAvLz0+IFdlIHdpbGwgY29tcHV0ZSB0aGUgb3B0aW9ucyBvYmplY3QgYmFzZWQgb24gdGhlIG9wdGlvbiBrZXlzIHRoYXQgYXJlIGtub3duIHRvIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgLy8gICBUaGF0IGF2b2lkcyBwYXNzaW5nIGEgZ2lnYW50aWMgb2JqZWN0IHRvIFN3ZWV0QWxlcnQyLCBtYWtpbmcgZGVidWdnaW5nIGVhc2llciBhbmQgcG90ZW50aWFsbHlcbiAgICAgICAgLy8gICBhdm9pZGluZyBzaWRlIGVmZmVjdHMuXG4gICAgICAgIHJldHVybiBbLi4udGhpcy50b3VjaGVkUHJvcHNdLnJlZHVjZTxTd2VldEFsZXJ0T3B0aW9ucz4oXG4gICAgICAgICAgICAob2JqLCBrZXkpID0+ICh7IC4uLm9iaiwgW2tleV06IHRoaXNba2V5IGFzIGtleW9mIHRoaXNdIH0pLFxuICAgICAgICAgICAge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZmlyZSB0aGUgbW9kYWwgYXMgc29vbiBhcyB0aGUgPHN3YWw+IGNvbXBvbmVudCBpcyBjcmVhdGVkIGFuZCBpbml0aWFsaXplZCBpbiB0aGUgdmlldy5cbiAgICAgKiBXaGVuIGxlZnQgdW5kZWZpbmVkIChkZWZhdWx0KSwgdGhlIHZhbHVlIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIG1vZHVsZSBjb25maWd1cmF0aW9uLCB3aGljaCBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKm5nSWY9XCJlcnJvclwiIFt0aXRsZV09XCJlcnJvci50aXRsZVwiIFt0ZXh0XT1cImVycm9yLnRleHRcIiBpY29uPVwiZXJyb3JcIiBbc3dhbEZpcmVPbkluaXRdPVwidHJ1ZVwiPjwvc3dhbD5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzd2FsRmlyZU9uSW5pdD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRpc21pc3MgdGhlIG1vZGFsIHdoZW4gdGhlIDxzd2FsPiBjb21wb25lbnQgaXMgZGVzdHJveWVkIGJ5IEFuZ3VsYXIgKGZvciBhbnkgcmVhc29uKSBvciBub3QuXG4gICAgICogV2hlbiBsZWZ0IHVuZGVmaW5lZCAoZGVmYXVsdCksIHRoZSB2YWx1ZSB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBtb2R1bGUgY29uZmlndXJhdGlvbiwgd2hpY2ggaXMgYHRydWVgLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN3YWxEaXNtaXNzT25EZXN0cm95PzogYm9vbGVhbjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzd2FsVmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKSB7XG4gICAgICAgIHZpc2libGUgPyB0aGlzLmZpcmUoKSA6IHRoaXMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHN3YWxWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRseVNob3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGFsIGxpZmVjeWNsZSBob29rLiBTeW5jaHJvbm91c2x5IHJ1bnMgYmVmb3JlIHRoZSBtb2RhbCBpcyBzaG93biBvbiBzY3JlZW4uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHdpbGxPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuV2lsbE9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIE1vZGFsIGxpZmVjeWNsZSBob29rLiBTeW5jaHJvbm91c2x5IHJ1bnMgYmVmb3JlIHRoZSBtb2RhbCBpcyBzaG93biBvbiBzY3JlZW4uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRpZE9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5EaWRPcGVuRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBNb2RhbCBsaWZlY3ljbGUgaG9vay4gU3luY2hyb25vdXNseSBydW5zIGFmdGVyIHRoZSBwb3B1cCBET00gaGFzIGJlZW4gdXBkYXRlZCAoaWUuIGp1c3QgYmVmb3JlIHRoZSBtb2RhbCBpc1xuICAgICAqIHJlcGFpbnRlZCBvbiB0aGUgc2NyZWVuKS5cbiAgICAgKiBUeXBpY2FsbHksIHRoaXMgd2lsbCBoYXBwZW4gYWZ0ZXIgYFN3YWwuZmlyZSgpYCBvciBgU3dhbC51cGRhdGUoKWAuXG4gICAgICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBjaGFuZ2VzIGluIHRoZSBwb3B1cCdzIERPTSwgdGhhdCBzdXJ2aXZlIGBTd2FsLnVwZGF0ZSgpYCwgcHJlZmVyIHtAbGluayBkaWRSZW5kZXJ9IG92ZXJcbiAgICAgKiB7QGxpbmsgd2lsbE9wZW59LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkaWRSZW5kZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5EaWRSZW5kZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIE1vZGFsIGxpZmVjeWNsZSBob29rLiBTeW5jaHJvbm91c2x5IHJ1bnMgd2hlbiB0aGUgcG9wdXAgY2xvc2VzIGJ5IHVzZXIgaW50ZXJhY3Rpb24gKGFuZCBub3QgZHVlIHRvIGFub3RoZXIgcG9wdXBcbiAgICAgKiBiZWluZyBmaXJlZCkuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHdpbGxDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLldpbGxDbG9zZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogTW9kYWwgbGlmZWN5Y2xlIGhvb2suIEFzeW5jaHJvbm91c2x5IHJ1bnMgYWZ0ZXIgdGhlIHBvcHVwIGhhcyBiZWVuIGRpc3Bvc2VkIGJ5IHVzZXIgaW50ZXJhY3Rpb24gKGFuZCBub3QgZHVlIHRvXG4gICAgICogYW5vdGhlciBwb3B1cCBiZWluZyBmaXJlZCkuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRpZENsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogTW9kYWwgbGlmZWN5Y2xlIGhvb2suIFN5bmNocm9ub3VzbHkgcnVucyBhZnRlciBwb3B1cCBoYXMgYmVlbiBkZXN0cm95ZWQgZWl0aGVyIGJ5IHVzZXIgaW50ZXJhY3Rpb24gb3IgYnkgYW5vdGhlclxuICAgICAqIHBvcHVwLlxuICAgICAqIElmIHlvdSBoYXZlIGNsZWFudXAgb3BlcmF0aW9ucyB0aGF0IHlvdSBuZWVkIHRvIHJlbGlhYmx5IGV4ZWN1dGUgZWFjaCB0aW1lIGEgbW9kYWwgaXMgY2xvc2VkLCBwcmVmZXJcbiAgICAgKiB7QGxpbmsgZGlkRGVzdHJveX0gb3ZlciB7QGxpbmsgZGlkQ2xvc2V9LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkaWREZXN0cm95ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25maXJtXCIuXG4gICAgICogVGhlIGV2ZW50IHZhbHVlICgkZXZlbnQpIGNhbiBiZSBlaXRoZXI6XG4gICAgICogIC0gYnkgZGVmYXVsdCwganVzdCBgdHJ1ZWAsXG4gICAgICogIC0gd2hlbiB1c2luZyB7QGxpbmsgaW5wdXR9LCB0aGUgaW5wdXQgdmFsdWUsXG4gICAgICogIC0gd2hlbiB1c2luZyB7QGxpbmsgcHJlQ29uZmlybX0sIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChjb25maXJtKT1cImhhbmRsZUNvbmZpcm0oJGV2ZW50KVwiPjwvc3dhbD5cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgaGFuZGxlQ29uZmlybShlbWFpbDogc3RyaW5nKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyAuLi4gc2F2ZSB1c2VyIGVtYWlsXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlybSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJEZW55XCIuXG4gICAgICogVGhpcyBldmVudCBiZWFycyBubyB2YWx1ZS5cbiAgICAgKiBVc2UgYChkZW55KWAgKGFsb25nIHdpdGgge0BsaW5rIHNob3dEZW55QnV0dG9ufSkgd2hlbiB5b3Ugd2FudCBhIG1vZGFsIHdpdGggdGhyZWUgYnV0dG9ucyAoY29uZmlybSwgZGVueSBhbmRcbiAgICAgKiBjYW5jZWwpLCBhbmQvb3Igd2hlbiB5b3Ugd2FudCB0byBoYW5kbGUgY2xlYXIgcmVmdXNhbCBpbiBhIHNlcGFyYXRlIHdheSB0aGFuIHNpbXBsZSBkaXNtaXNzYWwuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoZGVueSk9XCJoYW5kbGVEZW55KClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZURlbnkoKTogdm9pZCB7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGVueSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiQ2FuY2VsXCIsIG9yIGRpc21pc3NlcyB0aGUgbW9kYWwgYnkgYW55IG90aGVyIGFsbG93ZWQgd2F5LlxuICAgICAqIFRoZSBldmVudCB2YWx1ZSAoJGV2ZW50KSBpcyBhIHN0cmluZyB0aGF0IGV4cGxhaW5zIGhvdyB0aGUgbW9kYWwgd2FzIGRpc21pc3NlZC4gSXQgaXMgYHVuZGVmaW5lZGAgd2hlblxuICAgICAqIHRoZSBtb2RhbCB3YXMgcHJvZ3JhbW1hdGljYWxseSBjbG9zZWQgKHRocm91Z2gge0BsaW5rIGNsb3NlfSBmb3IgZXhhbXBsZSkuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoZGlzbWlzcyk9XCJoYW5kbGVEaXNtaXNzKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZURpc21pc3MocmVhc29uOiBEaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyByZWFzb24gY2FuIGJlICdjYW5jZWwnLCAnb3ZlcmxheScsICdjbG9zZScsICd0aW1lcicgb3IgdW5kZWZpbmVkLlxuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRpc21pc3MgPSBuZXcgRXZlbnRFbWl0dGVyPFN3YWwuRGlzbWlzc1JlYXNvbiB8IHVuZGVmaW5lZD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgU2V0IHJldGFpbnMgdGhlIHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gY2hhbmdlZCBmcm9tIEBJbnB1dHMsIHNvIHdlIGNhbiBrbm93IHByZWNpc2VseVxuICAgICAqIHdoYXQgb3B0aW9ucyB3ZSBoYXZlIHRvIHNlbmQgdG8ge0BsaW5rIFN3YWwuZmlyZX0uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSB0b3VjaGVkUHJvcHMgPSBuZXcgU2V0PGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zPigpO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiBvZiBzaWduYXR1cmUgYChwcm9wTmFtZTogc3RyaW5nKTogdm9pZGAgdGhhdCBhZGRzIGEgZ2l2ZW4gcHJvcGVydHkgbmFtZSB0byB0aGUgbGlzdCBvZlxuICAgICAqIHRvdWNoZWQgcHJvcGVydGllcywgaWUuIHtAbGluayB0b3VjaGVkUHJvcHN9LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbWFya1RvdWNoZWQgPSB0aGlzLnRvdWNoZWRQcm9wcy5hZGQuYmluZCh0aGlzLnRvdWNoZWRQcm9wcyk7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgU3dlZXRBbGVydDIgbW9kYWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBjb21wb25lbnQgY3VycmVudGx5IG9wZW5lZD9cbiAgICAgKi9cbiAgICBwcml2YXRlIGlzQ3VycmVudGx5U2hvd24gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzd2VldEFsZXJ0MkxvYWRlcjogU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KGZpcmVPbkluaXRUb2tlbikgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVMZXZlbEZpcmVPbkluaXQ6IGJvb2xlYW4sXG4gICAgICAgIEBJbmplY3QoZGlzbWlzc09uRGVzdHJveVRva2VuKSBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZUxldmVsRGlzbWlzc09uRGVzdHJveTogYm9vbGVhbikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogQXNrcyB0aGUgU3dlZXRBbGVydDIgbG9hZGVyIHNlcnZpY2UgdG8gcHJlbG9hZCB0aGUgU3dlZXRBbGVydDIgbGlicmFyeSwgc28gaXQgYmVnaW5zIHRvIGJlIGxvYWRlZCBvbmx5IGlmIHRoZXJlXG4gICAgICogaXMgYSA8c3dhbD4gY29tcG9uZW50IHNvbWV3aGVyZSwgYW5kIGlzIHByb2JhYmx5IGZ1bGx5IGxvYWRlZCB3aGVuIHRoZSBtb2RhbCBoYXMgdG8gYmUgZGlzcGxheWVkLFxuICAgICAqIGNhdXNpbmcgbm8gZGVsYXkuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvLz0+IFByZWxvYWQgU3dlZXRBbGVydDIgbGlicmFyeSBpbiBjYXNlIHRoaXMgY29tcG9uZW50IGlzIGFjdGl2YXRlZC5cbiAgICAgICAgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5wcmVsb2FkU3dlZXRBbGVydExpYnJhcnkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIEZpcmVzIHRoZSBtb2RhbCwgaWYgdGhlIGNvbXBvbmVudCBvciBtb2R1bGUgaXMgY29uZmlndXJlZCB0byBkbyBzby5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBmaXJlT25Jbml0ID0gdGhpcy5zd2FsRmlyZU9uSW5pdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRoaXMubW9kdWxlTGV2ZWxGaXJlT25Jbml0XG4gICAgICAgICAgICA6IHRoaXMuc3dhbEZpcmVPbkluaXQ7XG5cbiAgICAgICAgZmlyZU9uSW5pdCAmJiB0aGlzLmZpcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIFVwZGF0ZXMgdGhlIFN3ZWV0QWxlcnQgb3B0aW9ucywgYW5kIGlmIHRoZSBtb2RhbCBpcyBvcGVuZWQsIGFza3MgU3dlZXRBbGVydCB0byByZW5kZXIgaXQgYWdhaW4uXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgLy89PiBGb3IgZWFjaCBjaGFuZ2VkIEBJbnB1dCB0aGF0IG1hdGNoZXMgYSBTd2VldEFsZXJ0MiBvcHRpb24sIG1hcmsgYXMgdG91Y2hlZCBzbyB3ZSBjYW5cbiAgICAgICAgLy8gICBzZW5kIGl0IHdpdGggdGhlIG5leHQgZmlyZSgpIG9yIHVwZGF0ZSgpIGNhbGxzLlxuICAgICAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLy89PiBJZiB0aGUgZmlsdGVyaW5nIGxvZ2ljIGJlY29tZXMgbW9yZSBjb21wbGV4IGhlcmUsIHdlIGNhbiB1c2UgU3dhbC5pc1ZhbGlkUGFyYW1ldGVyXG4gICAgICAgICAgICAuZmlsdGVyKChrZXkpOiBrZXkgaXMga2V5b2YgU3dlZXRBbGVydE9wdGlvbnMgPT4gIWtleS5zdGFydHNXaXRoKCdzd2FsJykpXG4gICAgICAgICAgICAuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcblxuICAgICAgICAvLz0+IEV2ZW50dWFsbHkgdHJpZ2dlciByZS1yZW5kZXIgaWYgdGhlIG1vZGFsIGlzIG9wZW4uXG4gICAgICAgIHZvaWQgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIENsb3NlcyB0aGUgU3dlZXRBbGVydCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy89PiBSZWxlYXNlIHRoZSBtb2RhbCBpZiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBhbmQgaWYgdGhhdCBiZWhhdmlvdXIgaXMgbm90IGRpc2FibGVkLlxuICAgICAgICBjb25zdCBkaXNtaXNzT25EZXN0cm95ID0gdGhpcy5zd2FsRGlzbWlzc09uRGVzdHJveSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRoaXMubW9kdWxlTGV2ZWxEaXNtaXNzT25EZXN0cm95XG4gICAgICAgICAgICA6IHRoaXMuc3dhbERpc21pc3NPbkRlc3Ryb3k7XG5cbiAgICAgICAgZGlzbWlzc09uRGVzdHJveSAmJiB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIFN3ZWV0QWxlcnQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBTd2VldEFsZXJ0MiBwcm9taXNlIGZvciBjb252ZW5pZW5jZSBhbmQgdXNlIGluIGNvZGUgYmVoaW5kIHRlbXBsYXRlcy5cbiAgICAgKiBPdGhlcndpc2UsIChjb25maXJtKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgYW5kIChkaXNtaXNzKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgY2FuIGJlIHVzZWQgaW4gdGVtcGxhdGVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBmaXJlKCk6IFByb21pc2U8U3dlZXRBbGVydFJlc3VsdD4ge1xuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuXG4gICAgICAgIGNvbnN0IHVzZXJPcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcblxuICAgICAgICAvLz0+IEJ1aWxkIHRoZSBTd2VldEFsZXJ0MiBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zID0ge1xuICAgICAgICAgICAgLy89PiBNZXJnZSB3aXRoIGNhbGN1bGF0ZWQgb3B0aW9ucyBzZXQgZm9yIHRoYXQgc3BlY2lmaWMgc3dhbFxuICAgICAgICAgICAgLi4udXNlck9wdGlvbnMsXG5cbiAgICAgICAgICAgIC8vPT4gSGFuZGxlIG1vZGFsIGxpZmVjeWNsZSBldmVudHNcbiAgICAgICAgICAgIHdpbGxPcGVuOiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy53aWxsT3BlbiwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2lsbE9wZW4uZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGlkT3BlbjogY29tcG9zZUhvb2sodXNlck9wdGlvbnMuZGlkT3BlbiwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWRPcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRpZFJlbmRlcjogY29tcG9zZUhvb2sodXNlck9wdGlvbnMuZGlkUmVuZGVyLCAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWRSZW5kZXIuZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2lsbENsb3NlOiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy53aWxsQ2xvc2UsIChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLndpbGxDbG9zZS5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkaWRDbG9zZTogY29tcG9zZUhvb2sodXNlck9wdGlvbnMuZGlkQ2xvc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZENsb3NlLmVtaXQoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGlkRGVzdHJveTogY29tcG9zZUhvb2sodXNlck9wdGlvbnMuZGlkRGVzdHJveSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlkRGVzdHJveS5lbWl0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vPT4gU2hvdyB0aGUgU3dhbCEgQW5kIHdhaXQgZm9yIGNvbmZpcm1hdGlvbiBvciBkaW1pc3NhbC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3dhbC5maXJlKG9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gRW1pdCBvbiAoY29uZmlybSksIChkZW55KSBvciAoZGlzbWlzcylcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIHJlc3VsdC5pc0NvbmZpcm1lZDogdGhpcy5jb25maXJtLmVtaXQocmVzdWx0LnZhbHVlKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHJlc3VsdC5pc0RlbmllZDogdGhpcy5kZW55LmVtaXQoKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHJlc3VsdC5pc0Rpc21pc3NlZDogdGhpcy5kaXNtaXNzLmVtaXQocmVzdWx0LmRpc21pc3MpOyBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcG9zZUhvb2s8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD4oXG4gICAgICAgICAgICB1c2VySG9vazogVCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxpYkhvb2s6IFQpOiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4gdm9pZCB7XG5cbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gKGxpYkhvb2soLi4uYXJncyksIHVzZXJIb29rPy4oLi4uYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBtb2RhbCwgaWYgb3BlbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3VsdCBUaGUgdmFsdWUgdGhhdCB0aGUgbW9kYWwgd2lsbCByZXNvbHZlIHdpdGgsIHRyaWdnZXJpbmcgZWl0aGVyIChjb25maXJtKSwgKGRlbnkpIG9yIChkaXNtaXNzKS5cbiAgICAgKiAgICAgICAgICAgICAgIElmIHRoZSBhcmd1bWVudCBpcyBub3QgcGFzc2VkLCBpdCBpcyAoZGlzbWlzcykgdGhhdCB3aWxsIGVtaXQgYW4gYHVuZGVmaW5lZGAgcmVhc29uLlxuICAgICAqICAgICAgICAgICAgICAge0BzZWUgU3dhbC5jbG9zZX0uXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGNsb3NlKHJlc3VsdD86IFN3ZWV0QWxlcnRSZXN1bHQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5U2hvd24pIHJldHVybjtcblxuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuICAgICAgICBzd2FsLmNsb3NlKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBTd2VldEFsZXJ0MiBvcHRpb25zIHdoaWxlIHRoZSBtb2RhbCBpcyBvcGVuZWQsIGNhdXNpbmcgdGhlIG1vZGFsIHRvIHJlLXJlbmRlci5cbiAgICAgKiBJZiB0aGUgbW9kYWwgaXMgbm90IG9wZW5lZCwgdGhlIGNvbXBvbmVudCBvcHRpb25zIHdpbGwgc2ltcGx5IGJlIHVwZGF0ZWQgYW5kIHRoYXQncyBpdC5cbiAgICAgKlxuICAgICAqIC8hXFwgUGxlYXNlIG5vdGUgdGhhdCBub3QgYWxsIFN3ZWV0QWxlcnQyIG9wdGlvbnMgYXJlIHVwZGF0YWJsZSB3aGlsZSB0aGUgbW9kYWwgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlKG9wdGlvbnM/OiBQaWNrPFN3ZWV0QWxlcnRPcHRpb25zLCBTd2VldEFsZXJ0VXBkYXRhYmxlUGFyYW1ldGVycz4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5U2hvd24pIHJldHVybjtcblxuICAgICAgICBjb25zdCBzd2FsID0gYXdhaXQgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5zd2FsO1xuXG4gICAgICAgIGNvbnN0IGFsbE9wdGlvbnMgPSB0aGlzLnN3YWxPcHRpb25zO1xuXG4gICAgICAgIGNvbnN0IHVwZGF0YWJsZU9wdGlvbnMgPSBPYmplY3Qua2V5cyhhbGxPcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihzd2FsLmlzVXBkYXRhYmxlUGFyYW1ldGVyKVxuICAgICAgICAgICAgLnJlZHVjZTxQaWNrPFN3ZWV0QWxlcnRPcHRpb25zLCBTd2VldEFsZXJ0VXBkYXRhYmxlUGFyYW1ldGVycz4+KFxuICAgICAgICAgICAgICAgIChvYmosIGtleSkgPT4gKHsgLi4ub2JqLCBba2V5XTogYWxsT3B0aW9uc1trZXldIH0pLFxuICAgICAgICAgICAgICAgIHt9KTtcblxuICAgICAgICBzd2FsLnVwZGF0ZSh1cGRhdGFibGVPcHRpb25zKTtcbiAgICB9XG59XG4iXX0=