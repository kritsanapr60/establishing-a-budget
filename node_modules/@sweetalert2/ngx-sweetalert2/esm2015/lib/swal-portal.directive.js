import { __awaiter } from "tslib";
import { ApplicationRef, ComponentFactoryResolver, Directive, Host, Injector, Input, TemplateRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { SwalPortalTargets } from './swal-portal-targets.service';
import { SwalPortalComponent } from './swal-portal.component';
import { SwalComponent } from './swal.component';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * A structural directive that lets you use Angular templates inside of SweetAlerts.
 * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but
 * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.
 * The default target is the alert text content zone.
 *
 * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):
 *
 *     @Component({ ... })
 *     export class MyComponent {
 *         public constructor(public readonly swalTargets: SwalPortalTargets) {
 *         }
 *     }
 *
 * Usage in the template:
 *
 *     <swal title="Fill the form" (confirm)="confirmHandler()">
 *         <!-- This form will be displayed as the alert main content
 *              Targets the alert's main content zone by default -->
 *         <form *swalPortal [formControl]="myForm">
 *             ...
 *         </form>
 *
 *         <!-- This targets the confirm button's inner content
 *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
 *         <ng-container *swalPortal="swalTargets.confirmButton">
 *              Send ({{ secondsLeft }} seconds left)
 *         </ng-container>
 *     <swal>
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './sweetalert2-loader.service';
import * as ɵngcc2 from './swal-portal-targets.service';
import * as ɵngcc3 from './swal.component';
export class SwalPortalDirective {
    constructor(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {
        this.resolver = resolver;
        this.injector = injector;
        this.app = app;
        this.templateRef = templateRef;
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.swalTargets = swalTargets;
        this.swalComponent = swalComponent;
        this.destroyed = new Subject();
    }
    /**
     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
     * that will receive the consumer's template.
     */
    ngOnInit() {
        // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.
        this.target = this.target || this.swalTargets.content;
        //=> Apply the options provided by the target definition
        void this.swalComponent.update(this.target.options);
        //=> Subscribe to a few hooks frm the parent SwalComponent.
        this.swalComponent.didRender.pipe(takeUntil(this.destroyed)).subscribe(this.didRenderHook.bind(this));
        this.swalComponent.willOpen.pipe(takeUntil(this.destroyed)).subscribe(this.willOpenHook.bind(this));
        this.swalComponent.didDestroy.pipe(takeUntil(this.destroyed)).subscribe(this.didDestroyHook.bind(this));
    }
    /**
     * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the
     * parent SwalComponent events.
     */
    ngOnDestroy() {
        this.destroyed.next();
    }
    /**
     * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
     * {@link willOpenHook}), or after Swal.update() is called.
     * This is a good place to render, or re-render, our portal contents.
     */
    didRenderHook() {
        return __awaiter(this, void 0, void 0, function* () {
            //=> Ensure the portal component is created
            if (!this.portalComponentRef) {
                this.portalComponentRef = this.createPortalComponent();
            }
            //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.
            // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside
            // this function is already resolved at this point), so the whole process of re-rendering and re-mounting
            // the portal component is fully synchronous, causing no blinks in the modal contents.
            const swal = yield this.sweetAlert2Loader.swal;
            //=> Find target element
            const targetEl = this.target.element(swal);
            if (!targetEl)
                return;
            //=> Replace target's contents with our component
            // https://jsperf.com/innerhtml-vs-removechild/15
            while (targetEl.firstChild) {
                targetEl.removeChild(targetEl.firstChild);
            }
            targetEl.appendChild(this.portalComponentRef.location.nativeElement);
        });
    }
    /**
     * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.
     * This is a good place to declare our detached view to the Angular app.
     */
    willOpenHook() {
        if (!this.portalComponentRef)
            return;
        //=> Make the Angular app aware of that detached view so rendering and change detection can happen
        this.app.attachView(this.portalComponentRef.hostView);
    }
    /**
     * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.
     * This is a good place to detach and destroy our content, that is not visible anymore.
     */
    didDestroyHook() {
        if (!this.portalComponentRef)
            return;
        //=> Detach the portal component from the app and destroy it
        this.app.detachView(this.portalComponentRef.hostView);
        this.portalComponentRef.destroy();
        this.portalComponentRef = void 0;
    }
    /**
     * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.
     */
    createPortalComponent() {
        //=> Create the SwalPortalComponent that will hold our content
        const factory = this.resolver.resolveComponentFactory(SwalPortalComponent);
        // Yes, we do not use the third argument that would directly use the target as the component's view
        // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)
        // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be
        // able to restore it at any moment, ie. after the modal has been re-rendered.
        const componentRef = factory.create(this.injector, []);
        //=> Apply the consumer's template on the component
        componentRef.instance.template = this.templateRef;
        return componentRef;
    }
}
SwalPortalDirective.ɵfac = function SwalPortalDirective_Factory(t) { return new (t || SwalPortalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.SweetAlert2LoaderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.SwalPortalTargets), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.SwalComponent, 1)); };
SwalPortalDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SwalPortalDirective, selectors: [["", "swalPortal", ""]], inputs: { target: ["swalPortal", "target"] } });
SwalPortalDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: ApplicationRef },
    { type: TemplateRef },
    { type: SweetAlert2LoaderService },
    { type: SwalPortalTargets },
    { type: SwalComponent, decorators: [{ type: Host }] }
];
SwalPortalDirective.propDecorators = {
    target: [{ type: Input, args: ['swalPortal',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwalPortalDirective, [{
        type: Directive,
        args: [{
                selector: '[swalPortal]'
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc1.SweetAlert2LoaderService }, { type: ɵngcc2.SwalPortalTargets }, { type: ɵngcc3.SwalComponent, decorators: [{
                type: Host
            }] }]; }, { target: [{
            type: Input,
            args: ['swalPortal']
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC1wb3J0YWwuZGlyZWN0aXZlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc3dlZXRhbGVydDIvc3JjL2xpYi9zd2FsLXBvcnRhbC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDSCxjQUFjLEVBQUUsd0JBQXdCLEVBQWdCLFNBQVMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFDeEYsV0FBVyxFQUNkLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBb0IsaUJBQWlCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNwRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDakQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7Ozs7O0FBSUgsTUFBTSxPQUFPLG1CQUFtQjtBQUFHLElBaUIvQixZQUNxQixRQUFrQyxFQUNsQyxRQUFrQixFQUNsQixHQUFtQixFQUNuQixXQUE2QixFQUM3QixpQkFBMkMsRUFDM0MsV0FBOEIsRUFDdEIsYUFBNEI7QUFDN0QsUUFQeUIsYUFBUSxHQUFSLFFBQVEsQ0FBMEI7QUFBQyxRQUNuQyxhQUFRLEdBQVIsUUFBUSxDQUFVO0FBQUMsUUFDbkIsUUFBRyxHQUFILEdBQUcsQ0FBZ0I7QUFBQyxR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QUFBQztBQUE2QyxZQTNDL0Isd0JBQXdCO0FBQUksWUFBNkIsUUFBUTtBQUFJLFlBQXJGLGNBQWM7QUFBSSxZQUNsQixXQUFXO0FBQ1osWUFNTSx3QkFBd0I7QUFBSSxZQUhWLGlCQUFpQjtBQUFJLFlBRXZDLGFBQWEsdUJBNERiLElBQUk7QUFBTTtBQUFHO0FBQXVDLHFCQWpCeEQsS0FBSyxTQUFDLFlBQVk7QUFDbkI7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEFwcGxpY2F0aW9uUmVmLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgRGlyZWN0aXZlLCBIb3N0LCBJbmplY3RvciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LFxuICAgIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3dhbFBvcnRhbFRhcmdldCwgU3dhbFBvcnRhbFRhcmdldHMgfSBmcm9tICcuL3N3YWwtcG9ydGFsLXRhcmdldHMuc2VydmljZSc7XG5pbXBvcnQgeyBTd2FsUG9ydGFsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLXBvcnRhbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3dhbENvbXBvbmVudCB9IGZyb20gJy4vc3dhbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi9zd2VldGFsZXJ0Mi1sb2FkZXIuc2VydmljZSc7XG5cbi8qKlxuICogQSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0aGF0IGxldHMgeW91IHVzZSBBbmd1bGFyIHRlbXBsYXRlcyBpbnNpZGUgb2YgU3dlZXRBbGVydHMuXG4gKiBUaGVyZSBhcmUgZGlmZmVyZW50IHRhcmdldGFibGUgem9uZXMgcHJvdmlkZWQgYnkge0BsaW5rIFN3YWxQb3J0YWxUYXJnZXRzfTogdGl0bGUsIGNvbnRlbnQsIGNvbmZpcm1CdXR0b24sIGV0YywgYnV0XG4gKiB5b3UgY2FuIGFsc28gbWFrZSB5b3VyIG93biB0YXJnZXQgYnkgaW1wbGVtZW50aW5nIHtAbGluayBTd2FsUG9ydGFsVGFyZ2V0fSBhbmQgZ2l2aW5nIGl0IHRvIHRoaXMgZGlyZWN0aXZlLlxuICogVGhlIGRlZmF1bHQgdGFyZ2V0IGlzIHRoZSBhbGVydCB0ZXh0IGNvbnRlbnQgem9uZS5cbiAqXG4gKiBVc2FnZSBpbiB5b3VyIGNvbXBvbmVudCdzIFR5cGVTY3JpcHQgKGlmIHlvdSB1c2UgYW5vdGhlciB0YXJnZXQgdGhhbiB7QGxpbmsgU3dhbFBvcnRhbFRhcmdldHMuY29udGVudH0pOlxuICpcbiAqICAgICBAQ29tcG9uZW50KHsgLi4uIH0pXG4gKiAgICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgICAgICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzd2FsVGFyZ2V0czogU3dhbFBvcnRhbFRhcmdldHMpIHtcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBVc2FnZSBpbiB0aGUgdGVtcGxhdGU6XG4gKlxuICogICAgIDxzd2FsIHRpdGxlPVwiRmlsbCB0aGUgZm9ybVwiIChjb25maXJtKT1cImNvbmZpcm1IYW5kbGVyKClcIj5cbiAqICAgICAgICAgPCEtLSBUaGlzIGZvcm0gd2lsbCBiZSBkaXNwbGF5ZWQgYXMgdGhlIGFsZXJ0IG1haW4gY29udGVudFxuICogICAgICAgICAgICAgIFRhcmdldHMgdGhlIGFsZXJ0J3MgbWFpbiBjb250ZW50IHpvbmUgYnkgZGVmYXVsdCAtLT5cbiAqICAgICAgICAgPGZvcm0gKnN3YWxQb3J0YWwgW2Zvcm1Db250cm9sXT1cIm15Rm9ybVwiPlxuICogICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIDwvZm9ybT5cbiAqXG4gKiAgICAgICAgIDwhLS0gVGhpcyB0YXJnZXRzIHRoZSBjb25maXJtIGJ1dHRvbidzIGlubmVyIGNvbnRlbnRcbiAqICAgICAgICAgICAgICBOb3RpY2UgdGhlIHVzYWdlIG9mIG5nLWNvbnRhaW5lciB0byBhdm9pZCBjcmVhdGluZyBhbiB1c2VsZXNzIERPTSBlbGVtZW50IGluc2lkZSB0aGUgYnV0dG9uIC0tPlxuICogICAgICAgICA8bmctY29udGFpbmVyICpzd2FsUG9ydGFsPVwic3dhbFRhcmdldHMuY29uZmlybUJ1dHRvblwiPlxuICogICAgICAgICAgICAgIFNlbmQgKHt7IHNlY29uZHNMZWZ0IH19IHNlY29uZHMgbGVmdClcbiAqICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gKiAgICAgPHN3YWw+XG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3N3YWxQb3J0YWxdJ1xufSlcbmV4cG9ydCBjbGFzcyBTd2FsUG9ydGFsRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIFRha2VzIGEgcG9ydGFsIHRhcmdldCBvciBub3RoaW5nICh0aGVuIGl0IHdpbGwgdGFyZ2V0IHRoZSB0ZXh0IGNvbnRlbnQgem9uZSBieSBkZWZhdWx0KS5cbiAgICAgKlxuICAgICAqIFNlZSB0aGUge0BsaW5rIFN3YWxQb3J0YWxUYXJnZXRzfSBzZXJ2aWNlIHRvIHNlZSB0aGUgYXZhaWxhYmxlIHRhcmdldHMuXG4gICAgICogU2VlIHRoZSBjbGFzcyBkb2MgYmxvY2sgZm9yIG1vcmUgaW5mb3JtYXRpb25zLlxuICAgICAqL1xuICAgIEBJbnB1dCgnc3dhbFBvcnRhbCcpXG4gICAgcHVibGljIHRhcmdldD86IFN3YWxQb3J0YWxUYXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgY29tcG9uZW50IHJlZmVyZW5jZSBvZiB0aGUgY29udHJvbGxlZCBTd2FsUG9ydGFsQ29tcG9uZW50IHRvIGRlc3Ryb3kgaXQgd2hlbiBubyBsb25nZXIgbmVlZGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgcG9ydGFsQ29tcG9uZW50UmVmPzogQ29tcG9uZW50UmVmPFN3YWxQb3J0YWxDb21wb25lbnQ+O1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZXN0cm95ZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwbGljYXRpb25SZWYsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3dlZXRBbGVydDJMb2FkZXI6IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzd2FsVGFyZ2V0czogU3dhbFBvcnRhbFRhcmdldHMsXG4gICAgICAgIEBIb3N0KCkgcHJpdmF0ZSByZWFkb25seSBzd2FsQ29tcG9uZW50OiBTd2FsQ29tcG9uZW50KSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgdGhlIFN3ZWV0QWxlcnQgYXBwZWFyYW5jZS9kaXNhcHBlYXJhbmNlIGV2ZW50cyB0byBjcmVhdGUvZGVzdHJveSB0aGUgU3dhbFBvcnRhbENvbXBvbmVudFxuICAgICAqIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBjb25zdW1lcidzIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gQ2FuJ3QgYmUgc2V0IGluIGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSwgaWYgdGhlIGN1c3RvbWVyIGxldHMgKnN3YWxQb3J0YWwgZW1wdHksIHRoZSB2YWx1ZSB3ZSBnZXQgaXMgdW5kZWYuXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgdGhpcy5zd2FsVGFyZ2V0cy5jb250ZW50O1xuXG4gICAgICAgIC8vPT4gQXBwbHkgdGhlIG9wdGlvbnMgcHJvdmlkZWQgYnkgdGhlIHRhcmdldCBkZWZpbml0aW9uXG4gICAgICAgIHZvaWQgdGhpcy5zd2FsQ29tcG9uZW50LnVwZGF0ZSh0aGlzLnRhcmdldC5vcHRpb25zKTtcblxuICAgICAgICAvLz0+IFN1YnNjcmliZSB0byBhIGZldyBob29rcyBmcm0gdGhlIHBhcmVudCBTd2FsQ29tcG9uZW50LlxuICAgICAgICB0aGlzLnN3YWxDb21wb25lbnQuZGlkUmVuZGVyLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveWVkKSkuc3Vic2NyaWJlKHRoaXMuZGlkUmVuZGVySG9vay5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zd2FsQ29tcG9uZW50LndpbGxPcGVuLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveWVkKSkuc3Vic2NyaWJlKHRoaXMud2lsbE9wZW5Ib29rLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN3YWxDb21wb25lbnQuZGlkRGVzdHJveS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCkpLnN1YnNjcmliZSh0aGlzLmRpZERlc3Ryb3lIb29rLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpZ25hbCBhbnkge0BsaW5rIGRlc3Ryb3llZH0gY29uc3VtZXIgdGhhdCB0aGlzIGlzIG92ZXIsIHNvIHRoZXkgY2FuIHVuc3Vic2NyaWJlIGZyb20gdGhlXG4gICAgICogcGFyZW50IFN3YWxDb21wb25lbnQgZXZlbnRzLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQubmV4dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZGlkUmVuZGVyIGhvb2sgcnVucyAxLi5uIHRpbWVzIChwZXIgbW9kYWwgaW5zdGFuY2UpLCBqdXN0IGJlZm9yZSB0aGUgbW9kYWwgaXMgc2hvd24gKGFuZCBhbHNvIGJlZm9yZSB0aGVcbiAgICAgKiB7QGxpbmsgd2lsbE9wZW5Ib29rfSksIG9yIGFmdGVyIFN3YWwudXBkYXRlKCkgaXMgY2FsbGVkLlxuICAgICAqIFRoaXMgaXMgYSBnb29kIHBsYWNlIHRvIHJlbmRlciwgb3IgcmUtcmVuZGVyLCBvdXIgcG9ydGFsIGNvbnRlbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgZGlkUmVuZGVySG9vaygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy89PiBFbnN1cmUgdGhlIHBvcnRhbCBjb21wb25lbnQgaXMgY3JlYXRlZFxuICAgICAgICBpZiAoIXRoaXMucG9ydGFsQ29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBvcnRhbENvbXBvbmVudFJlZiA9IHRoaXMuY3JlYXRlUG9ydGFsQ29tcG9uZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLz0+IFN3ZWV0QWxlcnQyIGNyZWF0ZWQgdGhlIG1vZGFsIG9yIGp1c3QgZXJhc2VkIGFsbCBvZiBvdXIgY29udGVudCwgc28gd2UgbmVlZCB0byBpbnN0YWxsL3JlaW5zdGFsbCBpdC5cbiAgICAgICAgLy8gU3dhbC51cGRhdGUoKSBpcyBzeW5jaHJvbm91cywgdGhpcyBvYnNlcnZhYmxlIHRvbywgYW5kIG1vdW50Q29tcG9uZW50T25UYXJnZXQgdG9vICh0aGUgcHJvbWlzZSBpbnNpZGVcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBpcyBhbHJlYWR5IHJlc29sdmVkIGF0IHRoaXMgcG9pbnQpLCBzbyB0aGUgd2hvbGUgcHJvY2VzcyBvZiByZS1yZW5kZXJpbmcgYW5kIHJlLW1vdW50aW5nXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgY29tcG9uZW50IGlzIGZ1bGx5IHN5bmNocm9ub3VzLCBjYXVzaW5nIG5vIGJsaW5rcyBpbiB0aGUgbW9kYWwgY29udGVudHMuXG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG5cbiAgICAgICAgLy89PiBGaW5kIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy50YXJnZXQhLmVsZW1lbnQoc3dhbCk7XG4gICAgICAgIGlmICghdGFyZ2V0RWwpIHJldHVybjtcblxuICAgICAgICAvLz0+IFJlcGxhY2UgdGFyZ2V0J3MgY29udGVudHMgd2l0aCBvdXIgY29tcG9uZW50XG4gICAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9pbm5lcmh0bWwtdnMtcmVtb3ZlY2hpbGQvMTVcbiAgICAgICAgd2hpbGUgKHRhcmdldEVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUNoaWxkKHRhcmdldEVsLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0RWwuYXBwZW5kQ2hpbGQodGhpcy5wb3J0YWxDb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsT3BlbiBob29rIHJ1bnMgb25jZSAocGVyIG1vZGFsIGluc3RhbmNlKSwganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duIG9uIHRoZSBzY3JlZW4uXG4gICAgICogVGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gZGVjbGFyZSBvdXIgZGV0YWNoZWQgdmlldyB0byB0aGUgQW5ndWxhciBhcHAuXG4gICAgICovXG4gICAgcHJpdmF0ZSB3aWxsT3Blbkhvb2soKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5wb3J0YWxDb21wb25lbnRSZWYpIHJldHVybjtcblxuICAgICAgICAvLz0+IE1ha2UgdGhlIEFuZ3VsYXIgYXBwIGF3YXJlIG9mIHRoYXQgZGV0YWNoZWQgdmlldyBzbyByZW5kZXJpbmcgYW5kIGNoYW5nZSBkZXRlY3Rpb24gY2FuIGhhcHBlblxuICAgICAgICB0aGlzLmFwcC5hdHRhY2hWaWV3KHRoaXMucG9ydGFsQ29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGRpZERlc3Ryb3kgaG9vayBydW5zIG9uY2UgKHBlciBtb2RhbCBpbnN0YW5jZSksIGp1c3QgYWZ0ZXIgdGhlIG1vZGFsIGNsb3NpbmcgYW5pbWF0aW9uIHRlcm1pbmF0ZWQuXG4gICAgICogVGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gZGV0YWNoIGFuZCBkZXN0cm95IG91ciBjb250ZW50LCB0aGF0IGlzIG5vdCB2aXNpYmxlIGFueW1vcmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkaWREZXN0cm95SG9vaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvcnRhbENvbXBvbmVudFJlZikgcmV0dXJuO1xuXG4gICAgICAgIC8vPT4gRGV0YWNoIHRoZSBwb3J0YWwgY29tcG9uZW50IGZyb20gdGhlIGFwcCBhbmQgZGVzdHJveSBpdFxuICAgICAgICB0aGlzLmFwcC5kZXRhY2hWaWV3KHRoaXMucG9ydGFsQ29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgICAgdGhpcy5wb3J0YWxDb21wb25lbnRSZWYuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnBvcnRhbENvbXBvbmVudFJlZiA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB7QGxpbmsgU3dhbFBvcnRhbENvbXBvbmVudH0gYW5kIGdpdmVzIGl0IHRoZSBjdXN0b21lcidzIHRlbXBsYXRlIHJlZi5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZVBvcnRhbENvbXBvbmVudCgpOiBDb21wb25lbnRSZWY8U3dhbFBvcnRhbENvbXBvbmVudD4ge1xuICAgICAgICAvLz0+IENyZWF0ZSB0aGUgU3dhbFBvcnRhbENvbXBvbmVudCB0aGF0IHdpbGwgaG9sZCBvdXIgY29udGVudFxuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShTd2FsUG9ydGFsQ29tcG9uZW50KTtcblxuICAgICAgICAvLyBZZXMsIHdlIGRvIG5vdCB1c2UgdGhlIHRoaXJkIGFyZ3VtZW50IHRoYXQgd291bGQgZGlyZWN0bHkgdXNlIHRoZSB0YXJnZXQgYXMgdGhlIGNvbXBvbmVudCdzIHZpZXdcbiAgICAgICAgLy8gKHVuZm9ydHVuYXRlbHksIGJlY2F1c2UgdGhhdCB3b3VsZCBnaXZlIGEgY2xlYW5lciBET00gYW5kIHdvdWxkIGF2b2lkIGRpcnR5IGFuZCBkaXJlY3QgRE9NIG1hbmlwdWxhdGlvbnMpXG4gICAgICAgIC8vIFRoYXQncyBiZWNhdXNlIHdlIHdhbnQgdG8ga2VlcCBvdXIgY29tcG9uZW50IHNhZmUgZnJvbSBTd2VldEFsZXJ0MidzIG9wZXJhdGlvbnMgb24gdGhlIERPTSwgYW5kIHRvIGJlXG4gICAgICAgIC8vIGFibGUgdG8gcmVzdG9yZSBpdCBhdCBhbnkgbW9tZW50LCBpZS4gYWZ0ZXIgdGhlIG1vZGFsIGhhcyBiZWVuIHJlLXJlbmRlcmVkLlxuICAgICAgICBjb25zdCBjb21wb25lbnRSZWYgPSBmYWN0b3J5LmNyZWF0ZSh0aGlzLmluamVjdG9yLCBbXSk7XG5cbiAgICAgICAgLy89PiBBcHBseSB0aGUgY29uc3VtZXIncyB0ZW1wbGF0ZSBvbiB0aGUgY29tcG9uZW50XG4gICAgICAgIGNvbXBvbmVudFJlZi5pbnN0YW5jZS50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVSZWY7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcbiAgICB9XG59XG4iXX0=