{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module watchdog/editorwatchdog\n */\n\n/* globals console */\nimport { throttle, cloneDeepWith, isElement } from 'lodash-es';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\nimport Watchdog from './watchdog';\n/**\n * A watchdog for CKEditor 5 editors.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n *\n * @extends {module:watchdog/watchdog~Watchdog}\n */\n\nvar EditorWatchdog = /*#__PURE__*/function (_Watchdog) {\n  _inherits(EditorWatchdog, _Watchdog);\n\n  var _super = _createSuper(EditorWatchdog);\n\n  /**\n   * @param {*} Editor The editor class.\n   * @param {module:watchdog/watchdog~WatchdogConfig} [watchdogConfig] The watchdog plugin configuration.\n   */\n  function EditorWatchdog(Editor) {\n    var _this;\n\n    var watchdogConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, EditorWatchdog);\n\n    _this = _super.call(this, watchdogConfig);\n    /**\n     * The current editor instance.\n     *\n     * @private\n     * @type {module:core/editor/editor~Editor}\n     */\n\n    _this._editor = null;\n    /**\n     * Throttled save method. The `save()` method is called the specified `saveInterval` after `throttledSave()` is called,\n     * unless a new action happens in the meantime.\n     *\n     * @private\n     * @type {Function}\n     */\n\n    _this._throttledSave = throttle(_this._save.bind(_assertThisInitialized(_this)), typeof watchdogConfig.saveInterval === 'number' ? watchdogConfig.saveInterval : 5000);\n    /**\n     * The latest saved editor data represented as a root name -> root data object.\n     *\n     * @private\n     * @member {Object.<String,String>} #_data\n     */\n\n    /**\n     * The last document version.\n     *\n     * @private\n     * @member {Number} #_lastDocumentVersion\n     */\n\n    /**\n     * The editor source element or data.\n     *\n     * @private\n     * @member {HTMLElement|String|Object.<String|String>} #_elementOrData\n     */\n\n    /**\n     * The editor configuration.\n     *\n     * @private\n     * @member {Object|undefined} #_config\n     */\n    // Set default creator and destructor functions:\n\n    _this._creator = function (elementOrData, config) {\n      return Editor.create(elementOrData, config);\n    };\n\n    _this._destructor = function (editor) {\n      return editor.destroy();\n    };\n\n    return _this;\n  }\n  /**\n   * The current editor instance.\n   *\n   * @readonly\n   * @type {module:core/editor/editor~Editor}\n   */\n\n\n  _createClass(EditorWatchdog, [{\n    key: \"_restart\",\n\n    /**\n     * Sets the function that is responsible for the editor creation.\n     * It expects a function that should return a promise.\n     *\n     *\t\twatchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );\n     *\n     * @method #setCreator\n     * @param {Function} creator\n     */\n\n    /**\n     * Sets the function that is responsible for the editor destruction.\n     * Overrides the default destruction function, which destroys only the editor instance.\n     * It expects a function that should return a promise or `undefined`.\n     *\n     *\t\twatchdog.setDestructor( editor => {\n     *\t\t\t// Do something before the editor is destroyed.\n     *\n     *\t\t\treturn editor\n     *\t\t\t\t.destroy()\n     *\t\t\t\t.then( () => {\n     *\t\t\t\t\t// Do something after the editor is destroyed.\n     *\t\t\t\t} );\n     *\t\t} );\n     *\n     * @method #setDestructor\n     * @param {Function} destructor\n     */\n\n    /**\n     * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes\n     * the state to `initializing`.\n     *\n     * @protected\n     * @fires restart\n     * @returns {Promise}\n     */\n    value: function _restart() {\n      var _this2 = this;\n\n      return Promise.resolve().then(function () {\n        _this2.state = 'initializing';\n\n        _this2._fire('stateChange');\n\n        return _this2._destroy();\n      }).catch(function (err) {\n        console.error('An error happened during the editor destroying.', err);\n      }).then(function () {\n        if (typeof _this2._elementOrData === 'string') {\n          return _this2.create(_this2._data, _this2._config, _this2._config.context);\n        } else {\n          var updatedConfig = Object.assign({}, _this2._config, {\n            initialData: _this2._data\n          });\n          return _this2.create(_this2._elementOrData, updatedConfig, updatedConfig.context);\n        }\n      }).then(function () {\n        _this2._fire('restart');\n      });\n    }\n    /**\n     * Creates the editor instance and keeps it running, using the defined creator and destructor.\n     *\n     * @param {HTMLElement|String|Object.<String|String>} [elementOrData] The editor source element or the editor data.\n     * @param {module:core/editor/editorconfig~EditorConfig} [config] The editor configuration.\n     * @param {Object} [context] A context for the editor.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"create\",\n    value: function create() {\n      var _this3 = this;\n\n      var elementOrData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._elementOrData;\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._config;\n      var context = arguments.length > 2 ? arguments[2] : undefined;\n      return Promise.resolve().then(function () {\n        _get(_getPrototypeOf(EditorWatchdog.prototype), \"_startErrorHandling\", _this3).call(_this3);\n\n        _this3._elementOrData = elementOrData; // Clone configuration because it might be shared within multiple watchdog instances. Otherwise,\n        // when an error occurs in one of these editors, the watchdog will restart all of them.\n\n        _this3._config = _this3._cloneEditorConfiguration(config) || {};\n        _this3._config.context = context;\n        return _this3._creator(elementOrData, _this3._config);\n      }).then(function (editor) {\n        _this3._editor = editor;\n        editor.model.document.on('change:data', _this3._throttledSave);\n        _this3._lastDocumentVersion = editor.model.document.version;\n        _this3._data = _this3._getData();\n        _this3.state = 'ready';\n\n        _this3._fire('stateChange');\n      });\n    }\n    /**\n     * Destroys the watchdog and the current editor instance. It fires the callback\n     * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.\n     * It also sets the state to `destroyed`.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this4 = this;\n\n      return Promise.resolve().then(function () {\n        _this4.state = 'destroyed';\n\n        _this4._fire('stateChange');\n\n        _get(_getPrototypeOf(EditorWatchdog.prototype), \"destroy\", _this4).call(_this4);\n\n        return _this4._destroy();\n      });\n    }\n    /**\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      var _this5 = this;\n\n      return Promise.resolve().then(function () {\n        _this5._stopErrorHandling(); // Save data if there is a remaining editor data change.\n\n\n        _this5._throttledSave.flush();\n\n        var editor = _this5._editor;\n        _this5._editor = null;\n        return _this5._destructor(editor);\n      });\n    }\n    /**\n     * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at\n     * the moment of the crash.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_save\",\n    value: function _save() {\n      var version = this._editor.model.document.version; // Operation may not result in a model change, so the document's version can be the same.\n\n      if (version === this._lastDocumentVersion) {\n        return;\n      }\n\n      try {\n        this._data = this._getData();\n        this._lastDocumentVersion = version;\n      } catch (err) {\n        console.error(err, 'An error happened during restoring editor data. ' + 'Editor will be restored from the previously saved data.');\n      }\n    }\n    /**\n     * @protected\n     * @param {Set} props\n     */\n\n  }, {\n    key: \"_setExcludedProperties\",\n    value: function _setExcludedProperties(props) {\n      this._excludedProps = props;\n    }\n    /**\n     * Returns the editor data.\n     *\n     * @private\n     * @returns {Object<String,String>}\n     */\n\n  }, {\n    key: \"_getData\",\n    value: function _getData() {\n      var data = {};\n\n      var _iterator = _createForOfIteratorHelper(this._editor.model.document.getRootNames()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rootName = _step.value;\n          data[rootName] = this._editor.data.get({\n            rootName: rootName\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return data;\n    }\n    /**\n     * Traverses the error context and the current editor to find out whether these structures are connected\n     * to each other via properties.\n     *\n     * @protected\n     * @param {module:utils/ckeditorerror~CKEditorError} error\n     */\n\n  }, {\n    key: \"_isErrorComingFromThisItem\",\n    value: function _isErrorComingFromThisItem(error) {\n      return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);\n    }\n    /**\n     * Clones the editor configuration.\n     *\n     * @private\n     * @param {Object} config\n     */\n\n  }, {\n    key: \"_cloneEditorConfiguration\",\n    value: function _cloneEditorConfiguration(config) {\n      return cloneDeepWith(config, function (value, key) {\n        // Leave DOM references.\n        if (isElement(value)) {\n          return value;\n        }\n\n        if (key === 'context') {\n          return value;\n        }\n      });\n    }\n    /**\n     * Fired after the watchdog restarts the error in case of a crash.\n     *\n     * @event restart\n     */\n\n  }, {\n    key: \"editor\",\n    get: function get() {\n      return this._editor;\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_item\",\n    get: function get() {\n      return this._editor;\n    }\n  }]);\n\n  return EditorWatchdog;\n}(Watchdog);\n\nexport { EditorWatchdog as default };","map":null,"metadata":{},"sourceType":"module"}