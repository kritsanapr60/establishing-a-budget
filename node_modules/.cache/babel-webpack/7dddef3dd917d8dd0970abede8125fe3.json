{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kritsanaprasit/Desktop/establishing-a-budget/establishing-a-budget/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module watchdog/watchdog\n */\n\n/* globals window */\n\n/**\n * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.\n *\n * @private\n * @abstract\n */\nvar Watchdog = /*#__PURE__*/function () {\n  /**\n   * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.\n   */\n  function Watchdog(config) {\n    var _this = this;\n\n    _classCallCheck(this, Watchdog);\n\n    /**\n     * An array of crashes saved as an object with the following properties:\n     *\n     * * `message`: `String`,\n     * * `stack`: `String`,\n     * * `date`: `Number`,\n     * * `filename`: `String | undefined`,\n     * * `lineno`: `Number | undefined`,\n     * * `colno`: `Number | undefined`,\n     *\n     * @public\n     * @readonly\n     * @type {Array.<Object>}\n     */\n    this.crashes = [];\n    /**\n     * Specifies the state of the item watched by the watchdog. The state can be one of the following values:\n     *\n     * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.\n     * * `ready` &ndash; A state when the user can interact with the item.\n     * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`\n     * depending on how many and how frequent errors have been caught recently.\n     * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,\n     * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.\n     *\n     * @public\n     * @type {'initializing'|'ready'|'crashed'|'crashedPermanently'|'destroyed'}\n     */\n\n    this.state = 'initializing';\n    /**\n     * @protected\n     * @type {Number}\n     * @see module:watchdog/watchdog~WatchdogConfig\n     */\n\n    this._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;\n    /**\n     * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular\n     * approaches like `sinon.useFakeTimers()` do not work well with error handling.\n     *\n     * @protected\n     */\n\n    this._now = Date.now;\n    /**\n     * @protected\n     * @type {Number}\n     * @see module:watchdog/watchdog~WatchdogConfig\n     */\n\n    this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;\n    /**\n     * Checks if the event error comes from the underlying item and restarts the item.\n     *\n     * @private\n     * @type {Function}\n     */\n\n    this._boundErrorHandler = function (evt) {\n      // `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.\n      var error = evt.error || evt.reason; // Note that `evt.reason` might be everything that is in the promise rejection.\n      // Similarly everything that is thrown lands in `evt.error`.\n\n      if (error instanceof Error) {\n        _this._handleError(error, evt);\n      }\n    };\n    /**\n     * The creation method.\n     *\n     * @protected\n     * @member {Function} #_creator\n     * @see #setCreator\n     */\n\n    /**\n     * The destruction method.\n     *\n     * @protected\n     * @member {Function} #_destructor\n     * @see #setDestructor\n     */\n\n    /**\n     * The watched item.\n     *\n     * @abstract\n     * @protected\n     * @member {Object|undefined} #_item\n     */\n\n    /**\n     * The method responsible for restarting the watched item.\n     *\n     * @abstract\n     * @protected\n     * @method #_restart\n     */\n\n    /**\n     * Traverses the error context and the watched item to find out whether the error should\n     * be handled by the given item.\n     *\n     * @abstract\n     * @protected\n     * @method #_isErrorComingFromThisItem\n     * @param {module:utils/ckeditorerror~CKEditorError} error\n     */\n\n    /**\n     * A dictionary of event emitter listeners.\n     *\n     * @private\n     * @type {Object.<String,Array.<Function>>}\n     */\n\n\n    this._listeners = {};\n\n    if (!this._restart) {\n      throw new Error('The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' + 'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.');\n    }\n  }\n  /**\n   * Sets the function that is responsible for creating watched items.\n   *\n   * @param {Function} creator A callback responsible for creating an item. Returns a promise\n   * that is resolved when the item is created.\n   */\n\n\n  _createClass(Watchdog, [{\n    key: \"setCreator\",\n    value: function setCreator(creator) {\n      this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for destroying watched items.\n     *\n     * @param {Function} destructor A callback that takes the item and returns the promise\n     * to the destroying process.\n     */\n\n  }, {\n    key: \"setDestructor\",\n    value: function setDestructor(destructor) {\n      this._destructor = destructor;\n    }\n    /**\n     * Destroys the watchdog and releases the resources.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._stopErrorHandling();\n\n      this._listeners = {};\n    }\n    /**\n     * Starts listening to a specific event name by registering a callback that will be executed\n     * whenever an event with a given name fires.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param {String} eventName The event name.\n     * @param {Function} callback A callback which will be added to event listeners.\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      if (!this._listeners[eventName]) {\n        this._listeners[eventName] = [];\n      }\n\n      this._listeners[eventName].push(callback);\n    }\n    /**\n     * Stops listening to the specified event name by removing the callback from event listeners.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param {String} eventName The event name.\n     * @param {Function} callback A callback which will be removed from event listeners.\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, callback) {\n      this._listeners[eventName] = this._listeners[eventName].filter(function (cb) {\n        return cb !== callback;\n      });\n    }\n    /**\n     * Fires an event with a given event name and arguments.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @protected\n     * @param {String} eventName The event name.\n     * @param  {...*} args Event arguments.\n     */\n\n  }, {\n    key: \"_fire\",\n    value: function _fire(eventName) {\n      var callbacks = this._listeners[eventName] || [];\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var _iterator = _createForOfIteratorHelper(callbacks),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var callback = _step.value;\n          callback.apply(this, [null].concat(args));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Starts error handling by attaching global error handlers.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_startErrorHandling\",\n    value: function _startErrorHandling() {\n      window.addEventListener('error', this._boundErrorHandler);\n      window.addEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Stops error handling by detaching global error handlers.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_stopErrorHandling\",\n    value: function _stopErrorHandling() {\n      window.removeEventListener('error', this._boundErrorHandler);\n      window.removeEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Checks if an error comes from the watched item and restarts it.\n     * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.\n     *\n     * @private\n     * @fires error\n     * @param {Error} error Error.\n     * @param {ErrorEvent|PromiseRejectionEvent} evt An error event.\n     */\n\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(error, evt) {\n      // @if CK_DEBUG // if ( error.is && error.is( 'CKEditorError' ) && error.context === undefined ) {\n      // @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );\n      // @if CK_DEBUG // }\n      if (this._shouldReactToError(error)) {\n        this.crashes.push({\n          message: error.message,\n          stack: error.stack,\n          // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events\n          filename: evt.filename,\n          lineno: evt.lineno,\n          colno: evt.colno,\n          date: this._now()\n        });\n\n        var causesRestart = this._shouldRestart();\n\n        this.state = 'crashed';\n\n        this._fire('stateChange');\n\n        this._fire('error', {\n          error: error,\n          causesRestart: causesRestart\n        });\n\n        if (causesRestart) {\n          this._restart();\n        } else {\n          this.state = 'crashedPermanently';\n\n          this._fire('stateChange');\n        }\n      }\n    }\n    /**\n     * Checks whether an error should be handled by the watchdog.\n     *\n     * @private\n     * @param {Error} error An error that was caught by the error handling process.\n     */\n\n  }, {\n    key: \"_shouldReactToError\",\n    value: function _shouldReactToError(error) {\n      return error.is && error.is('CKEditorError') && error.context !== undefined && // In some cases the watched item should not be restarted - e.g. during the item initialization.\n      // That's why the `null` was introduced as a correct error context which does cause restarting.\n      error.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.\n      this.state === 'ready' && this._isErrorComingFromThisItem(error);\n    }\n    /**\n     * Checks if the watchdog should restart the underlying item.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_shouldRestart\",\n    value: function _shouldRestart() {\n      if (this.crashes.length <= this._crashNumberLimit) {\n        return true;\n      }\n\n      var lastErrorTime = this.crashes[this.crashes.length - 1].date;\n      var firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;\n      var averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;\n      return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;\n    }\n    /**\n     * Fired when a new {@link module:utils/ckeditorerror~CKEditorError `CKEditorError`} error connected to the watchdog instance occurs\n     * and the watchdog will react to it.\n     *\n     * \twatchdog.on( 'error', ( evt, { error, causesRestart } ) => {\n     * \t\tconsole.log( 'An error occurred.' );\n     * \t} );\n     *\n     * @event error\n     */\n\n  }]);\n\n  return Watchdog;\n}();\n/**\n * The watchdog plugin configuration.\n *\n * @typedef {Object} WatchdogConfig\n *\n * @property {Number} [crashNumberLimit=3] A threshold specifying the number of watched item crashes\n * when the watchdog stops restarting the item in case of errors.\n * After this limit is reached and the time between the last errors is shorter than `minimumNonErrorTimePeriod`,\n * the watchdog changes its state to `crashedPermanently` and it stops restarting the item. This prevents an infinite restart loop.\n *\n * @property {Number} [minimumNonErrorTimePeriod=5000] An average number of milliseconds between the last watched item errors\n * (defaults to 5000). When the period of time between errors is lower than that and the `crashNumberLimit` is also reached,\n * the watchdog changes its state to `crashedPermanently` and it stops restarting the item. This prevents an infinite restart loop.\n *\n * @property {Number} [saveInterval=5000] A minimum number of milliseconds between saving the editor data internally (defaults to 5000).\n * Note that for large documents this might impact the editor performance.\n */\n\n\nexport { Watchdog as default };","map":null,"metadata":{},"sourceType":"module"}